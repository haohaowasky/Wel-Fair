import { IProofShare, IVerifiedData, IProof, ResponseData } from './types';
import { TAttestationTypeNames } from '@bloomprotocol/attestations-lib';
import { TDecodedLog } from './txUtils';
export declare const stripHexPrefix: (hexStr: string) => string;
export declare const toBuffer: (s: string) => Buffer;
export declare const isNullOrWhiteSpace: (value: any) => boolean;
export declare function sortObject<T>(object: any): T;
export declare const formatProofForVerify: (proof: IProofShare[]) => IProof[];
export declare const formatProofForShare: (proof: IProof[]) => IProofShare[];
export declare type TVerificationError = {
    key: string;
    error: string;
};
export declare const verifyProof: (data: IVerifiedData) => boolean;
/**
 * Given an `IverifiedData` object this function will verify off chain data properties such as
 * - Verifies that when hashing the rootHash and rootHash nonce the layer2Hash that's recovered
 * matches what was provided
 * - Confirms that the attester addresses provided matches the recovered address when recovering
 * via `ecrecover` using the attestationNode and signature provided
 * - Verifies the merkle proof using the root hash and target node (signed attestation)
 *
 * @param data Object of type `IverifiedData` declared in `types.ts`
 * @return If all verifications succeed an empty array is returned, otherwise any verification
 * issues are reported back as an array of `TVerificationError` objects.
 */
export declare const verifyOffChainDataIntegrity: (data: IVerifiedData) => TVerificationError[];
export declare const verifySender: (responseData: ResponseData) => TVerificationError[];
export declare const verifyPackedData: (responseData: ResponseData) => TVerificationError[];
export interface IDecodedDataAndLogs {
    shareData: IVerifiedData;
    logs: TDecodedLog[];
}
export interface IConsumableData {
    data: string;
    type: TAttestationTypeNames;
    version: string;
    logs?: TDecodedLog[];
}
export interface IValidatedPayloadData {
    data: IVerifiedData;
    errors: TVerificationError[];
    logs?: TDecodedLog[];
}
export interface IValidateResponseDataOutput {
    errors: TVerificationError[];
    data: IConsumableData[];
}
export interface IValidateResponseDataOptions {
    validateOnChain: boolean;
    web3Provider?: string;
}
export interface IRetrieveTxDataOutput {
    logs: TDecodedLog[];
    errors: TVerificationError[];
}
export declare const retreiveTxData: (payloadData: IVerifiedData, web3Provider: string) => Promise<IRetrieveTxDataOutput>;
export declare const validateResponseData: (responseData: ResponseData, options: IValidateResponseDataOptions) => Promise<IValidateResponseDataOutput>;
//# sourceMappingURL=util.d.ts.map