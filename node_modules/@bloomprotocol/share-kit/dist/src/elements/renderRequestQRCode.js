"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var types_1 = require("../types");
var QRCodeImpl = require('qr.js/lib/QRCode');
var defaultOptions = {
    hideLogo: false,
    ecLevel: 'L',
    size: 128,
    bgColor: '#fff',
    fgColor: '#6067f1',
    padding: 0,
};
var makeDot = function (ctx, info) {
    var centerX = info.left + info.size / 2;
    var centerY = info.top + info.size / 2;
    var radius = (info.size / 2) * 0.85;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = info.color;
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    ctx.fill();
    ctx.closePath();
    ctx.restore();
};
var makeRect = function (ctx, color, rect) {
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
};
var CornerType;
(function (CornerType) {
    CornerType[CornerType["none"] = 0] = "none";
    CornerType[CornerType["topLeft"] = 1] = "topLeft";
    CornerType[CornerType["topRight"] = 2] = "topRight";
    CornerType[CornerType["bottomRight"] = 3] = "bottomRight";
    CornerType[CornerType["bottomLeft"] = 4] = "bottomLeft";
})(CornerType || (CornerType = {}));
var makeCorner = function (ctx, info, type, part) {
    var outerRadius = part === EyePart.outer ? info.size : info.size / 4;
    var innerRadius = outerRadius / 2;
    var top = info.top, left = info.left;
    var bottom = top + info.size;
    var right = left + info.size;
    var halfSize = info.size / 2;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = info.color;
    ctx.strokeStyle = info.color;
    ctx.lineWidth = 1;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    switch (type) {
        case CornerType.topLeft:
            ctx.moveTo(left, bottom);
            ctx.arcTo(left, top, right, top, outerRadius);
            ctx.lineTo(right, top);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right + halfSize, bottom);
            ctx.arcTo(right, bottom, right, bottom + 5, innerRadius);
            ctx.lineTo(right, bottom + 5);
            ctx.lineTo(right, bottom);
            ctx.lineTo(left, bottom);
            break;
        case CornerType.topRight:
            ctx.moveTo(left, bottom);
            ctx.lineTo(left, top);
            ctx.arcTo(right, top, right, bottom, outerRadius);
            ctx.lineTo(right, bottom);
            ctx.lineTo(left, bottom);
            ctx.lineTo(left, bottom + halfSize);
            ctx.arcTo(left, bottom, left - halfSize, bottom, innerRadius);
            ctx.lineTo(left - halfSize, bottom);
            ctx.lineTo(left, bottom);
            break;
        case CornerType.bottomRight:
            ctx.moveTo(left, bottom);
            ctx.lineTo(left, top);
            ctx.lineTo(left - halfSize, top);
            ctx.arcTo(left, top, left, top - halfSize, innerRadius);
            ctx.lineTo(left, top - halfSize);
            ctx.lineTo(left, top);
            ctx.lineTo(right, top);
            ctx.arcTo(right, bottom, left, bottom, outerRadius);
            ctx.lineTo(left, bottom);
            break;
        case CornerType.bottomLeft:
            ctx.moveTo(left, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top - halfSize);
            ctx.arcTo(right, top, right + halfSize, top, innerRadius);
            ctx.lineTo(right + halfSize, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, bottom);
            ctx.arcTo(left, bottom, left, top, outerRadius);
            ctx.lineTo(left, top);
            break;
        default:
            break;
    }
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
};
var ConnectionType = /** @class */ (function () {
    function ConnectionType() {
    }
    ConnectionType.none = 0;
    ConnectionType.left = 1 << 0;
    ConnectionType.right = 1 << 1;
    ConnectionType.top = 1 << 2;
    ConnectionType.bottom = 1 << 4;
    return ConnectionType;
}());
var EyePart;
(function (EyePart) {
    EyePart[EyePart["inner"] = 0] = "inner";
    EyePart[EyePart["outer"] = 1] = "outer";
})(EyePart || (EyePart = {}));
var makeEyeBit = function (ctx, info, connectionType, part) {
    var centerX = info.left + info.size / 2;
    var centerY = info.top + info.size / 2;
    var halfSize = info.size / 2;
    var isLeft = (connectionType & ConnectionType.left) === ConnectionType.left;
    var isRight = (connectionType & ConnectionType.right) === ConnectionType.right;
    var isTop = (connectionType & ConnectionType.top) === ConnectionType.top;
    var isBottom = (connectionType & ConnectionType.bottom) === ConnectionType.bottom;
    if (isLeft !== isRight && isTop !== isBottom) {
        var cornerType = CornerType.none;
        if (isBottom && isRight) {
            cornerType = CornerType.topRight;
        }
        else if (isBottom && isLeft) {
            cornerType = CornerType.topLeft;
        }
        else if (isTop && isRight) {
            cornerType = CornerType.bottomRight;
        }
        else if (isTop && isLeft) {
            cornerType = CornerType.bottomLeft;
        }
        makeCorner(ctx, info, cornerType, part);
    }
    else {
        if (isLeft) {
            makeRect(ctx, info.color, { x: centerX, y: info.top, w: halfSize, h: info.size });
        }
        if (isRight) {
            makeRect(ctx, info.color, { x: info.left, y: info.top, w: halfSize, h: info.size });
        }
        if (isTop) {
            makeRect(ctx, info.color, { x: info.left, y: info.top, w: info.size, h: halfSize });
        }
        if (isBottom) {
            makeRect(ctx, info.color, { x: info.left, y: centerY, w: info.size, h: halfSize });
        }
    }
};
var drawCanvas = function (canvas, data, qrOptions) {
    var options = __assign({}, defaultOptions, qrOptions);
    var ecLevel = options.ecLevel, size = options.size, bgColor = options.bgColor, fgColor = options.fgColor, padding = options.padding;
    var qr = new QRCodeImpl(-1, types_1.ErrorCorrectionLevel[ecLevel]);
    qr.addData(JSON.stringify(data));
    qr.make();
    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var scale = window.devicePixelRatio || 1;
    var cells = qr.modules;
    var cellSize = size / cells.length;
    // Add 4 to account for:
    // - The 1 extra on top and left of each cell
    // - The 1 extra from the border on top/left
    canvas.height = canvas.width = size * scale + 4;
    canvas.style.height = canvas.style.width = size + "px";
    canvas.style.padding = (100 * padding) / size + '%';
    ctx.scale(scale, scale);
    makeRect(ctx, bgColor, { x: 0, y: 0, w: size, h: size });
    cells.forEach(function (row, rowIndex) {
        row.forEach(function (cell, cellIndex) {
            // This is a data bit
            if (cell) {
                var isTopLeftEye = cellIndex <= 7 && rowIndex <= 7;
                var isTopRightEye = cellIndex >= cells.length - 7 && rowIndex <= 7;
                var isBottomLeftEye = cellIndex <= 7 && rowIndex >= row.length - 7;
                var isEye = isTopLeftEye || isTopRightEye || isBottomLeftEye;
                // Add an extra 1 to the top/left so the border isn't cut off by the edge of the canvas
                var cellInfo = {
                    color: fgColor,
                    left: cellIndex * cellSize + 1,
                    top: rowIndex * cellSize + 1,
                    size: cellSize,
                };
                // Round the edges of eye bits
                if (isEye) {
                    var connectionType = ConnectionType.none;
                    if (rowIndex > 0 && cells[rowIndex - 1][cellIndex]) {
                        connectionType = connectionType | ConnectionType.top;
                    }
                    if (rowIndex < cells.length - 1 && cells[rowIndex + 1][cellIndex]) {
                        connectionType = connectionType | ConnectionType.bottom;
                    }
                    if (cellIndex > 0 && cells[rowIndex][cellIndex - 1]) {
                        connectionType = connectionType | ConnectionType.right;
                    }
                    if (cellIndex < row.length - 1 && cells[rowIndex][cellIndex + 1]) {
                        connectionType = connectionType | ConnectionType.left;
                    }
                    var isInnerEyeX = (cellIndex >= 2 && cellIndex <= 4) || (cellIndex >= cells.length - 7 && cellIndex <= cells.length);
                    var isInnerEyeY = (rowIndex >= 2 && rowIndex <= 4) || (rowIndex >= cells.length - 5 && rowIndex <= cells.length - 3);
                    var isInnerEye = isInnerEyeX && isInnerEyeY;
                    var eyePart = isInnerEye ? EyePart.inner : EyePart.outer;
                    makeEyeBit(ctx, cellInfo, connectionType, eyePart);
                }
                else {
                    makeDot(ctx, cellInfo);
                }
            }
        });
    });
    // If hideLogo is true then don't render any logo
    // If logoImage is not set default to BloomLogo with colors matching the rest of the QR code
    // Otherwise display the provided logo
    if (!options.hideLogo) {
        var logoImage = options.logoImage === undefined ? utils_1.getBloomLogo({ fgColor: fgColor, bgColor: bgColor }) : options.logoImage;
        var image_1 = new Image();
        image_1.onload = function () {
            var numberOfCellsToCover = Math.floor(cells.length * 0.2);
            var addExtra = numberOfCellsToCover % 2 === 0;
            var defaultWidth = numberOfCellsToCover * cellSize + (addExtra ? cellSize : 0);
            var dwidth = options.logoWidth || defaultWidth;
            var dheight = options.logoHeight || dwidth;
            // Add 1 to accomodate for the 1 shift of the cells
            var dx = (size - dwidth) / 2 + 1;
            var dy = (size - dheight) / 2 + 1;
            image_1.width = dwidth;
            image_1.height = dheight;
            ctx.save();
            ctx.globalAlpha = options.logoOpacity || 1;
            ctx.drawImage(image_1, dx, dy, dwidth, dheight);
            ctx.restore();
        };
        image_1.src = logoImage;
    }
};
var renderRequestQRCode = function (config) {
    var id = utils_1.generateId();
    var canvas = document.createElement('canvas');
    canvas.id = id;
    drawCanvas(canvas, config.requestData, config.qrOptions);
    config.container.append(canvas);
    return {
        update: updateRequestQRCode(id, config.container),
        remove: removeRequestQRCode(id, config.container),
    };
};
exports.renderRequestQRCode = renderRequestQRCode;
var updateRequestQRCode = function (id, container) { return function (config) {
    var canvas = container.querySelector("#" + id);
    if (!canvas)
        return;
    drawCanvas(canvas, config.requestData, config.qrOptions);
}; };
var removeRequestQRCode = function (id, container) { return function () {
    var canvas = container.querySelector("#" + id);
    if (canvas)
        canvas.remove();
}; };
//# sourceMappingURL=renderRequestQRCode.js.map