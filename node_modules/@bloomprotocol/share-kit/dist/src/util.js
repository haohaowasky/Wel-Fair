"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var attestations_lib_1 = require("@bloomprotocol/attestations-lib");
var lodash_1 = __importDefault(require("lodash"));
var js_sha3_1 = require("js-sha3");
var txUtils_1 = require("./txUtils");
exports.stripHexPrefix = function (hexStr) {
    if (hexStr.length < 2)
        return hexStr;
    if (hexStr.slice(0, 2) === '0x')
        return hexStr.slice(2);
    return hexStr;
};
exports.toBuffer = function (s) { return new Buffer(exports.stripHexPrefix(s), 'hex'); };
exports.isNullOrWhiteSpace = function (value) { return typeof value !== 'string' || value.trim() === ''; };
// Implementation from http://whitfin.io/sorting-object-recursively-node-jsjavascript/
function sortObject(object) {
    var sortedObj = {};
    var keys = lodash_1.default.keys(object);
    keys = lodash_1.default.sortBy(keys, function (key) {
        return key;
    });
    lodash_1.default.each(keys, function (key) {
        if (typeof object[key] === 'object' && !(object[key] instanceof Array)) {
            sortedObj[key] = sortObject(object[key]);
        }
        else {
            sortedObj[key] = object[key];
        }
    });
    return sortedObj;
}
exports.sortObject = sortObject;
exports.formatProofForVerify = function (proof) {
    return proof.map(function (node) {
        return {
            position: node.position,
            data: exports.toBuffer(node.data),
        };
    });
};
exports.formatProofForShare = function (proof) {
    return proof.map(function (node) {
        return {
            position: node.position,
            data: '0x' + node.data.toString('hex'),
        };
    });
};
exports.verifyProof = function (data) {
    var proof = exports.formatProofForVerify(data.proof);
    var targetNode = exports.toBuffer(attestations_lib_1.HashingLogic.hashMessage(data.target.signedAttestation));
    var root = exports.toBuffer(data.rootHash);
    return attestations_lib_1.HashingLogic.verifyMerkleProof(proof, targetNode, root);
};
/**
 * Given an `IverifiedData` object this function will verify off chain data properties such as
 * - Verifies that when hashing the rootHash and rootHash nonce the layer2Hash that's recovered
 * matches what was provided
 * - Confirms that the attester addresses provided matches the recovered address when recovering
 * via `ecrecover` using the attestationNode and signature provided
 * - Verifies the merkle proof using the root hash and target node (signed attestation)
 *
 * @param data Object of type `IverifiedData` declared in `types.ts`
 * @return If all verifications succeed an empty array is returned, otherwise any verification
 * issues are reported back as an array of `TVerificationError` objects.
 */
exports.verifyOffChainDataIntegrity = function (data) {
    var errors = [];
    // confirm root hash becomes layer 2 hash - hash(rootHash, rootHashnonce)
    var recoveredLayer2Hash = attestations_lib_1.HashingLogic.hashMessage(attestations_lib_1.HashingLogic.orderedStringify({
        rootHash: data.rootHash,
        nonce: data.rootHashNonce,
    }));
    if (data.layer2Hash !== recoveredLayer2Hash) {
        errors.push({
            key: 'layer2Hash',
            error: "The provided 'layer2Hash' doesn't match the value" +
                " recovered for the given 'rootHash' and 'rootHashNonce'.",
        });
    }
    // confirm attester signature of target node
    var recoveredAttesterAddress = attestations_lib_1.HashingLogic.recoverHashSigner(attestations_lib_1.HashingLogic.hashAttestationNode(data.target.attestationNode), data.target.signedAttestation);
    if (data.attester !== recoveredAttesterAddress) {
        errors.push({
            key: 'attester',
            error: "The provided 'attester' doesn't match the value" +
                " recovered for the target 'attestationNode' and 'signedAttestation'.",
        });
    }
    // verify merkle proof
    if (!exports.verifyProof(data)) {
        errors.push({
            key: 'proof',
            error: "The provided 'proof' is invalid for the given 'signedAttestation' and 'rootHash'.",
        });
    }
    return errors;
};
exports.verifySender = function (responseData) {
    var errors = [];
    var signerEthAddress = attestations_lib_1.HashingLogic.recoverHashSigner(exports.toBuffer(responseData.packedData), responseData.signature);
    // Here is where chained authorizations would be checked if present
    if (responseData.subject !== signerEthAddress) {
        errors.push({
            key: 'subject',
            error: "The recovered subject address based on the 'packedData' and 'signature'" +
                ' does not match the one that was shared.' +
                ("\nShared subject address: '" + responseData.subject + "'") +
                ("\nRecovered subject address: '" + signerEthAddress + "'"),
        });
    }
    return errors;
};
exports.verifyPackedData = function (responseData) {
    var errors = [];
    var recoveredPackedData = '0x' +
        js_sha3_1.keccak256(JSON.stringify({
            data: responseData.data,
            token: responseData.token,
        }));
    if (responseData.packedData !== recoveredPackedData) {
        errors.push({
            key: 'packedData',
            error: "The recovered packed data hash computed by running 'keccak256' on an object" +
                " containing the shared 'data' and 'token' does not match the 'packedData'" +
                ' that was shared.' +
                ("\nShared packed data: '" + responseData.packedData + "'") +
                ("\nRecovered packed data: '" + recoveredPackedData + "'"),
        });
    }
    return errors;
};
exports.retreiveTxData = function (payloadData, web3Provider) { return __awaiter(_this, void 0, void 0, function () {
    var txHash, logs, errors, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                txHash = payloadData.tx;
                logs = [];
                errors = [];
                if (!(exports.isNullOrWhiteSpace(txHash) || txHash === '0x')) return [3 /*break*/, 1];
                errors.push({
                    key: 'tx',
                    error: "tx is missing in payload for node with hash " + payloadData.layer2Hash,
                });
                return [3 /*break*/, 4];
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, txUtils_1.getDecodedTxEventLogs(web3Provider, txHash)];
            case 2:
                logs = _a.sent();
                return [3 /*break*/, 4];
            case 3:
                err_1 = _a.sent();
                errors.push({
                    key: 'getDecodedLogsFailed',
                    error: "" + err_1,
                });
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/, {
                    logs: logs,
                    errors: errors,
                }];
        }
    });
}); };
var validateOnChainProperties = function (subject, payloadData, logs) {
    var errors = [];
    // verify subject shared dataHash matches chain by using it as a part of the find logic
    var matchingTraitAttestedLogs = logs &&
        logs.find(function (l) { return l.name === 'TraitAttested' && txUtils_1.getDecodedLogValueByName(l, 'dataHash') === payloadData.layer2Hash; });
    if (!matchingTraitAttestedLogs) {
        errors.push({
            key: 'TraitAttested',
            error: "Unable to find 'TraitAttested' event logs with a" + (" 'dataHash' of '" + payloadData.layer2Hash + "'."),
        });
        return errors;
    }
    // verify shared subject address matches chain
    var onChainSubjectAddress = txUtils_1.getDecodedLogValueByName(matchingTraitAttestedLogs, 'subject');
    if (subject !== onChainSubjectAddress) {
        errors.push({
            key: 'subject',
            error: 'The on chain subject address does not match what was shared.' +
                ("\nShared subject address: '" + subject + "'") +
                ("\nOn chain subject address: '" + onChainSubjectAddress + "'"),
        });
    }
    // verify shared attester address matches chain
    var onChainAttesterAddress = txUtils_1.getDecodedLogValueByName(matchingTraitAttestedLogs, 'attester');
    if (payloadData.attester !== onChainAttesterAddress) {
        errors.push({
            key: 'attester',
            error: 'The on chain attester address does not match what was shared.' +
                ("\nShared attester address: '" + payloadData.attester + "'") +
                ("\nOn chain attester address: '" + onChainAttesterAddress + "'"),
        });
    }
    return errors;
};
exports.validateResponseData = function (responseData, options) { return __awaiter(_this, void 0, void 0, function () {
    var errors, shareKitPayload, consumableData;
    var _this = this;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (options.validateOnChain && exports.isNullOrWhiteSpace(options.web3Provider)) {
                    throw new Error('Unable to `validateOnChain` without a `web3Provider`.');
                }
                errors = [];
                shareKitPayload = sortObject(responseData);
                shareKitPayload.data = shareKitPayload.data.map(function (d) { return sortObject(d); });
                // Validate the integrity of basic off-chain properties (subject, packedData)
                errors.push.apply(errors, exports.verifySender(shareKitPayload));
                errors.push.apply(errors, exports.verifyPackedData(shareKitPayload));
                consumableData = [];
                return [4 /*yield*/, Promise.all(shareKitPayload.data.map(function (d) { return __awaiter(_this, void 0, void 0, function () {
                        var dTemp, retreiveTxDataOutput, err_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dTemp = {
                                        data: d.target.attestationNode.data.data,
                                        type: d.target.attestationNode.type.type,
                                        version: d.target.attestationNode.data.version,
                                    };
                                    if (!options.validateOnChain) return [3 /*break*/, 4];
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, exports.retreiveTxData(d, options.web3Provider)];
                                case 2:
                                    retreiveTxDataOutput = _a.sent();
                                    errors.push.apply(errors, retreiveTxDataOutput.errors);
                                    dTemp.logs = retreiveTxDataOutput.logs;
                                    errors.push.apply(errors, validateOnChainProperties(responseData.subject, d, dTemp.logs));
                                    return [3 /*break*/, 4];
                                case 3:
                                    err_2 = _a.sent();
                                    errors.push({
                                        key: 'onChainValidationFailed',
                                        error: "Failed to validate on chain data integrity for node with hash " + d.layer2Hash,
                                    });
                                    return [3 /*break*/, 4];
                                case 4:
                                    consumableData.push(dTemp);
                                    return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 1:
                _a.sent();
                return [2 /*return*/, {
                        errors: errors,
                        data: consumableData,
                    }];
        }
    });
}); };
//# sourceMappingURL=util.js.map