"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var js_sha3_1 = require("js-sha3");
var crypto = require('crypto');
var merkletreejs_1 = __importDefault(require("merkletreejs"));
var ethUtil = require('ethereumjs-util');
var ethSigUtil = require('eth-sig-util');
exports.hashMessage = function (message) {
    return ethUtil.addHexPrefix(js_sha3_1.keccak256(message));
};
/**
 * Generate a random hex string with 0x prefix
 */
exports.generateNonce = function () { return exports.hashMessage(crypto.randomBytes(20)); };
/**
 * Returns the value of `JSON.stringify` of a new object argument `obj`,
 * which is a copy of `obj`, but its properties are sorted using
 * `Array<string>.sort`.
 */
exports.orderedStringify = function (obj) {
    var orderedObj = {};
    Object.keys(obj)
        .sort()
        .map(function (o) { return (orderedObj[o] = obj[o]); });
    return JSON.stringify(orderedObj);
};
/**
 * Given an array of hashed attestations, creates a new MerkleTree with the leaves
 * after the leaves are sorted by hash and mapped into hash Buffers.
 */
exports.getMerkleTreeFromLeaves = function (leaves) {
    var leavesSorted = leaves.sort().map(function (hexStr) { return ethUtil.toBuffer(hexStr); });
    return new merkletreejs_1.default(leavesSorted, function (x) {
        return Buffer.from(js_sha3_1.keccak256(x), 'hex');
    });
};
/**
 *
 * @param attestation Given the contents of an attestation node, return a
 * Merkle tree
 */
exports.getDataTree = function (attestation) {
    var dataHash = exports.hashMessage(exports.orderedStringify(attestation.data));
    var typeHash = exports.hashMessage(exports.orderedStringify(attestation.type));
    var linkHash = exports.hashMessage(exports.orderedStringify(attestation.link));
    var auxHash = exports.hashMessage(attestation.aux);
    return exports.getMerkleTreeFromLeaves([dataHash, typeHash, linkHash, auxHash]);
};
/**
 * Given the contents of an attestation node, return the root hash of the Merkle tree
 */
exports.hashAttestationNode = function (attestation) {
    var dataTree = exports.getDataTree(attestation);
    return dataTree.getRoot();
};
/**
 * Sign a buffer with a given private key and return a hex string of the signature
 * @param hash Any message buffer
 * @param privKey A private key buffer
 */
exports.signHash = function (hash, privKey) {
    var sig = ethUtil.ecsign(hash, privKey);
    return ethSigUtil.concatSig(sig.v, sig.r, sig.s);
};
/**
 * Recover the address of the signer of a given message hash
 * @param hash Buffer of the message that was signed
 * @param sig Hex string of the signature
 */
exports.recoverHashSigner = function (hash, sig) {
    var signature = ethUtil.toBuffer(sig);
    var sigParams = ethUtil.fromRpcSig(signature);
    var pubKey = ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
    var sender = ethUtil.publicToAddress(pubKey);
    return ethUtil.bufferToHex(sender);
};
/**
 * Given an array of hashed dataNode signatures and a hashed checksum signature, creates a new MerkleTree
 * after padding, and sorting.
 *
 */
exports.getBloomMerkleTree = function (dataHashes, paddingNodes, checksumHash) {
    var leaves = dataHashes;
    leaves.push(checksumHash);
    leaves = leaves.concat(paddingNodes);
    return exports.getMerkleTreeFromLeaves(leaves);
};
/**
 * Given an array of root hashes, sort and hash them into a checksum buffer
 * @param {string[]} dataHashes - array of dataHashes as hex strings
 */
exports.getChecksum = function (dataHashes) {
    return ethUtil.toBuffer(exports.hashMessage(JSON.stringify(dataHashes.sort())));
};
/**
 * Given an array of root hashes, get and sign the checksum
 * @param dataHashes - array of dataHashes as hex strings
 * @param privKey - private key of signer
 */
exports.signChecksum = function (dataHashes, privKey) {
    return exports.signHash(exports.getChecksum(dataHashes), privKey);
};
/**
 * Sign a complete attestation node and return an object containing the datanode and the signature
 * @param dataNode - Complete attestation data node
 * @param globalRevocationLink - Hex string referencing revocation of the whole attestation
 * @param privKey - Private key of signer
 */
exports.getSignedDataNode = function (dataNode, globalRevocationLink, privKey) {
    var attestationNode = {
        data: dataNode.data,
        type: dataNode.type,
        aux: dataNode.aux,
        link: {
            local: exports.generateNonce(),
            global: globalRevocationLink,
            dataHash: exports.hashMessage(exports.orderedStringify(dataNode.data)),
            typeHash: exports.hashMessage(exports.orderedStringify(dataNode.type)),
        },
    };
    var attestationHash = exports.hashAttestationNode(attestationNode);
    var attestationSig = exports.signHash(attestationHash, privKey);
    return {
        attestationNode: attestationNode,
        signedAttestation: attestationSig,
    };
};
/**
 * Given the number of data nodes return an array of padding nodes
 * @param {number} dataCount - number of data nodes in tree
 *
 * A Bloom Merkle tree will contain at minimum one data node and one checksum node
 * In order to obscure the amount of data in the tree, the number of nodes are padded to
 * a set threshold
 *
 * The Depth of the tree increments in steps of 5
 * The number of terminal nodes in a filled binary tree is 2 ^ (n - 1) where n is the depth
 *
 * dataCount 1 -> 15: paddingCount: 14 -> 0 (remeber + 1 for checksum node)
 * dataCount 16 -> 511: paddingCount 495 -> 0
 * dataCount 512 -> ...: paddingCount 15871 -> ...
 * ...
 */
exports.getPadding = function (dataCount) {
    if (dataCount < 1)
        return [];
    var i = 5;
    while (dataCount + 1 > Math.pow(2, (i - 1))) {
        i += 5;
    }
    var paddingCount = Math.pow(2, (i - 1)) - (dataCount + 1);
    return Array.apply(null, Array(paddingCount)).map(function (item, index) {
        return exports.hashMessage(crypto.randomBytes(20));
    });
};
/**
 * Given attestation data and the attester's private key, construct the entire Bloom Merkle tree
 * and return the components needed to generate proofs
 * @param dataNodes - Complete attestation nodes
 * @param privKey - Attester private key
 */
exports.getSignedMerkleTreeComponents = function (dataNodes, privKey) {
    var globalRevocationLink = exports.generateNonce();
    var signedDataNodes = dataNodes.map(function (a) {
        return exports.getSignedDataNode(a, globalRevocationLink, privKey);
    });
    var signedDataHashes = signedDataNodes.map(function (a) {
        return exports.hashMessage(a.signedAttestation);
    });
    var paddingNodes = exports.getPadding(signedDataHashes.length);
    var signedChecksum = exports.signChecksum(signedDataHashes, privKey);
    var signedChecksumHash = exports.hashMessage(signedChecksum);
    var rootHash = exports.getBloomMerkleTree(signedDataHashes, paddingNodes, signedChecksumHash).getRoot();
    var signedRootHash = exports.signHash(rootHash, privKey);
    var rootHashNonce = exports.generateNonce();
    var layer2Hash = exports.hashMessage(exports.orderedStringify({
        rootHash: ethUtil.bufferToHex(rootHash),
        nonce: rootHashNonce,
    }));
    return {
        layer2Hash: layer2Hash,
        signedRootHash: signedRootHash,
        rootHashNonce: rootHashNonce,
        rootHash: ethUtil.bufferToHex(rootHash),
        dataNodes: signedDataNodes,
        checksumSig: signedChecksum,
        paddingNodes: paddingNodes,
    };
};
exports.getMerkleTreeFromComponents = function (components) {
    var signedDataHashes = components.dataNodes.map(function (a) {
        return exports.hashMessage(a.signedAttestation);
    });
    return exports.getBloomMerkleTree(signedDataHashes, components.paddingNodes, exports.hashMessage(components.checksumSig));
};
/**
 * verify
 * @desc Returns true if the proof path (array of hashes) can connect the target node
 * to the Merkle root.
 * @param {Object[]} proof - Array of proof objects that should connect
 * target node to Merkle root.
 * @param {Buffer} targetNode - Target node Buffer
 * @param {Buffer} root - Merkle root Buffer
 * @return {Boolean}
 * @example
 * const root = tree.getRoot()
 * const proof = tree.getProof(leaves[2])
 * const verified = tree.verify(proof, leaves[2], root)
 *
 * standalone verify function taken from https://github.com/miguelmota/merkletreejs
 */
exports.verifyMerkleProof = function (proof, targetNode, root) {
    // Should not succeed with all empty arguments
    // Proof can be empty if single leaf tree
    if (targetNode.toString() === '' || root.toString() === '') {
        return false;
    }
    // Initialize hash with only targetNode data
    var hash = targetNode;
    // Build hash using each component of proof until the root node
    proof.forEach(function (node) {
        var isLeftNode = node.position === 'left';
        var buffers = [hash];
        buffers[isLeftNode ? 'unshift' : 'push'](node.data);
        hash = Buffer.from(js_sha3_1.keccak256(Buffer.concat(buffers)), 'hex');
    });
    return Buffer.compare(hash, root) === 0;
};
var ChainId;
(function (ChainId) {
    ChainId[ChainId["Main"] = 1] = "Main";
    ChainId[ChainId["Rinkeby"] = 4] = "Rinkeby";
})(ChainId = exports.ChainId || (exports.ChainId = {}));
exports.getAttestationAgreement = function (contractAddress, chainId, dataHash, requestNonce) {
    return {
        types: {
            EIP712Domain: [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
                { name: 'chainId', type: 'uint256' },
                { name: 'verifyingContract', type: 'address' },
            ],
            AttestationRequest: [
                { name: 'dataHash', type: 'bytes32' },
                { name: 'nonce', type: 'bytes32' }
            ]
        },
        primaryType: 'AttestationRequest',
        domain: {
            name: 'Bloom Attestation Logic',
            version: '2',
            chainId: chainId,
            verifyingContract: contractAddress,
        },
        message: {
            dataHash: dataHash,
            nonce: requestNonce
        }
    };
};
//# sourceMappingURL=HashingLogic.js.map