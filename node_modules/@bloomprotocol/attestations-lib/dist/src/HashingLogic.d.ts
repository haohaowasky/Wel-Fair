/// <reference types="node" />
import { AttestationTypeID } from './AttestationTypes';
import MerkleTree, { IProof } from 'merkletreejs';
export declare const hashMessage: (message: string) => any;
/**
 * Generate a random hex string with 0x prefix
 */
export declare const generateNonce: () => any;
export interface IAttestationData {
    /**
     * String representation of the attestations data.
     *
     * ### Examples ###
     * email: "test@bloom.co"
     * sanction-screen: {\"firstName\":\"FIRSTNAME\",\"middleName\":\"MIDDLENAME\",\"lastName\":\"LASTNAME\",\"birthMonth\":1,\"birthDay\":1,\"birthYear\":1900,\"id\":\"a1a1a1a...\"}
     *
     * Any attestation that isn't a single string value will be
     * a JSON string representing the attestation data.
     */
    data: string;
    /**
     * Attestation data nonce
     */
    nonce: string;
    /**
     * Semantic version used to keep track of attestation versions
     */
    version: string;
}
export interface IAttestationType {
    /**
     * The type of attestation (phone, email, etc.)
     */
    type: keyof typeof AttestationTypeID;
    /**
     * Optionally identifies service used to perform attestation
     */
    provider?: string;
    /**
     * Attestation type nonce
     */
    nonce: string;
}
export interface IRevocationLinks {
    /**
     * Hex string to identify this attestation node in the event of partial revocation
     */
    local: string;
    /**
     * Hex string to identify this attestation in the event of revocation
     */
    global: string;
    /**
     * hash of data node attester is verifying
     */
    dataHash: string;
    /**
     * hash of type node attester is verifying
     */
    typeHash: string;
}
export interface IAuxSig {
    /**
     * Hex string containing subject's auxiliary signature
     * Signs the ordered stringified object containing
     * { dataHash: hashAttestation(IAttestationData), typeHash: hashAttestation(IAttestationType)}
     */
    signedHash: string;
    /**
     * Nonce to conceal unwanted revealing of aux public key
     */
    nonce: string;
}
export interface IAttestation {
    data: IAttestationData;
    type: IAttestationType;
    /**
     * aux either contains a hash of IAuxSig or just a padding node hash
     */
    aux: string;
}
export interface IAttestationNode extends IAttestation {
    link: IRevocationLinks;
}
export interface IDataNode {
    attestationNode: IAttestationNode;
    signedAttestation: string;
}
export interface IBloomMerkleTreeComponents {
    layer2Hash: string;
    signedRootHash: string;
    rootHashNonce: string;
    rootHash: string;
    dataNodes: IDataNode[];
    checksumSig: string;
    paddingNodes: string[];
}
/**
 * Returns the value of `JSON.stringify` of a new object argument `obj`,
 * which is a copy of `obj`, but its properties are sorted using
 * `Array<string>.sort`.
 */
export declare const orderedStringify: (obj: {}) => string;
/**
 * Given an array of hashed attestations, creates a new MerkleTree with the leaves
 * after the leaves are sorted by hash and mapped into hash Buffers.
 */
export declare const getMerkleTreeFromLeaves: (leaves: string[]) => MerkleTree;
/**
 *
 * @param attestation Given the contents of an attestation node, return a
 * Merkle tree
 */
export declare const getDataTree: (attestation: IAttestationNode) => MerkleTree;
/**
 * Given the contents of an attestation node, return the root hash of the Merkle tree
 */
export declare const hashAttestationNode: (attestation: IAttestationNode) => Buffer;
/**
 * Sign a buffer with a given private key and return a hex string of the signature
 * @param hash Any message buffer
 * @param privKey A private key buffer
 */
export declare const signHash: (hash: Buffer, privKey: Buffer) => string;
/**
 * Recover the address of the signer of a given message hash
 * @param hash Buffer of the message that was signed
 * @param sig Hex string of the signature
 */
export declare const recoverHashSigner: (hash: Buffer, sig: string) => any;
/**
 * Given an array of hashed dataNode signatures and a hashed checksum signature, creates a new MerkleTree
 * after padding, and sorting.
 *
 */
export declare const getBloomMerkleTree: (dataHashes: string[], paddingNodes: string[], checksumHash: string) => MerkleTree;
/**
 * Given an array of root hashes, sort and hash them into a checksum buffer
 * @param {string[]} dataHashes - array of dataHashes as hex strings
 */
export declare const getChecksum: (dataHashes: string[]) => Buffer;
/**
 * Given an array of root hashes, get and sign the checksum
 * @param dataHashes - array of dataHashes as hex strings
 * @param privKey - private key of signer
 */
export declare const signChecksum: (dataHashes: string[], privKey: Buffer) => string;
/**
 * Sign a complete attestation node and return an object containing the datanode and the signature
 * @param dataNode - Complete attestation data node
 * @param globalRevocationLink - Hex string referencing revocation of the whole attestation
 * @param privKey - Private key of signer
 */
export declare const getSignedDataNode: (dataNode: IAttestation, globalRevocationLink: string, privKey: Buffer) => IDataNode;
/**
 * Given the number of data nodes return an array of padding nodes
 * @param {number} dataCount - number of data nodes in tree
 *
 * A Bloom Merkle tree will contain at minimum one data node and one checksum node
 * In order to obscure the amount of data in the tree, the number of nodes are padded to
 * a set threshold
 *
 * The Depth of the tree increments in steps of 5
 * The number of terminal nodes in a filled binary tree is 2 ^ (n - 1) where n is the depth
 *
 * dataCount 1 -> 15: paddingCount: 14 -> 0 (remeber + 1 for checksum node)
 * dataCount 16 -> 511: paddingCount 495 -> 0
 * dataCount 512 -> ...: paddingCount 15871 -> ...
 * ...
 */
export declare const getPadding: (dataCount: number) => string[];
/**
 * Given attestation data and the attester's private key, construct the entire Bloom Merkle tree
 * and return the components needed to generate proofs
 * @param dataNodes - Complete attestation nodes
 * @param privKey - Attester private key
 */
export declare const getSignedMerkleTreeComponents: (dataNodes: IAttestation[], privKey: Buffer) => IBloomMerkleTreeComponents;
export declare const getMerkleTreeFromComponents: (components: IBloomMerkleTreeComponents) => MerkleTree;
/**
 * verify
 * @desc Returns true if the proof path (array of hashes) can connect the target node
 * to the Merkle root.
 * @param {Object[]} proof - Array of proof objects that should connect
 * target node to Merkle root.
 * @param {Buffer} targetNode - Target node Buffer
 * @param {Buffer} root - Merkle root Buffer
 * @return {Boolean}
 * @example
 * const root = tree.getRoot()
 * const proof = tree.getProof(leaves[2])
 * const verified = tree.verify(proof, leaves[2], root)
 *
 * standalone verify function taken from https://github.com/miguelmota/merkletreejs
 */
export declare const verifyMerkleProof: (proof: IProof[], targetNode: Buffer, root: Buffer) => boolean;
export declare enum ChainId {
    Main = 1,
    Rinkeby = 4
}
export interface ITypedDataParam {
    name: string;
    type: string;
}
export interface IFormattedTypedData {
    types: {
        EIP712Domain: ITypedDataParam[];
        [key: string]: ITypedDataParam[];
    };
    primaryType: string;
    domain: {
        name: string;
        version: string;
        chainId: number;
        verifyingContract: string;
    };
    message: {
        [key: string]: string;
    };
}
export declare const getAttestationAgreement: (contractAddress: string, chainId: number, dataHash: string, requestNonce: string) => IFormattedTypedData;
//# sourceMappingURL=HashingLogic.d.ts.map